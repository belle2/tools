#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
import os
import pwd
import subprocess
import datetime

# check for help option
if len(sys.argv) != 2 or sys.argv[1] in ['--help', '-h', '-?']:
    sys.stderr.write("""
Usage: newmod modulename

This command creates a source code template for a module.

""")
    sys.exit(0)

module = sys.argv[1]

# define relpath for python < 2.6
if not hasattr(os.path, 'relpath'):

    def relpath(path, start=os.path.curdir):
        """Return a relative version of a path"""

        if not path:
            raise ValueError('no path specified')

        start_list = os.path.abspath(start).split(os.path.sep)
        path_list = os.path.abspath(path).split(os.path.sep)

        # Work out how much of the filepath is shared by start and path.
        i = len(os.path.commonprefix([start_list, path_list]))

        rel_list = [os.path.pardir] * (len(start_list) - i) + path_list[i:]
        if not rel_list:
            return os.path.curdir
        return os.path.join(*rel_list)

    os.path.relpath = relpath


# set header and source file names
header = module + 'Module.h'
src = module + 'Module.cc'
if os.path.isdir('include') and os.path.isdir('src'):
    header = os.path.join('include', header)
    src = os.path.join('src', src)

# check whether the files already exist
if os.path.isfile(header) or os.path.isfile(src):
    sys.stderr.write('ERROR: The file %s or %s already exists.\n' % (header,
                     src))
    sys.exit(1)

# make sure we have an analysis or local release directory
local_dir = os.environ.get('BELLE2_ANALYSIS_DIR',
                           os.environ.get('BELLE2_LOCAL_DIR', ''))
if local_dir == '':
    sys.stderr.write('ERROR: No analysis or local release is set up.\n')
    sys.exit(1)

# get author name
sys.stdout.write('Your name [%s]: ' % os.getlogin())
author = sys.stdin.readline().strip('\n')
if author == '':
    author = os.getlogin()

# get module description
sys.stdout.write('Short module description: ')
short_desc = sys.stdin.readline().strip('\n')
sys.stdout.write('Long module description (finish with ctrl-D):\n')
long_desc = sys.stdin.readlines()

# get module parameters
params_header = ''
params_src = ''
param_types = {
    'i': 'int',
    'd': 'double',
    's': 'std::string',
    'b': 'bool',
    'vi': 'std::vector<int>',
    'vd': 'std::vector<double>',
    'vs': 'std::vector<std::string>',
    'vb': 'std::vector<bool>',
    }
sys.stdout.write("""Please enter the module parameters one by one.
Enter an empty name to finish the list of module parameters.
The following key words for parameter types can be used:
i for int, d for double, s for string, b for bool.
Add a v before the type letter for vectors.
All other strings will be taken directly as type names.
""")
while True:
    sys.stdout.write('  Name            : ')
    param_name = sys.stdin.readline().strip('\n')
    if param_name == '':
        break
    sys.stdout.write('    Type          : ')
    param_type = sys.stdin.readline().strip('\n')
    if param_type in param_types.keys():
        param_type = param_types[param_type]
    sys.stdout.write('    Description   : ')
    param_desc = sys.stdin.readline().strip('\n')
    param_def = ''
    if param_type.find('<') < 0:
        sys.stdout.write('    Default [none]: ')
        param_def = sys.stdin.readline().strip('\n')
        if param_type == 'std::string':
            if not param_def.startswith('"'):
                param_def = '"' + param_def + '"'
            param_def = 'std::string(' + param_def + ')'
    params_header = params_header + '    %s m_%s;  /**< %s */\n' \
        % (param_type, param_name, param_desc)
    if param_def == '':
        params_src = params_src + '  addParam("%s", m_%s, "%s");\n' \
            % (param_name, param_name, param_desc)
    else:
        params_src = params_src + '  addParam("%s", m_%s, "%s", %s);\n' \
            % (param_name, param_name, param_desc, param_def)

# get module input and output
header_includes = []
src_includes = []
ctor_src = ''
init_header = ''
init_src = ''
sys.stdout.write('Please enter the required/optional input data types:\n')
while True:
    sys.stdout.write('  Input type             : ')
    io_class = sys.stdin.readline().strip('\n')
    if io_class == '':
        break
    sys.stdout.write('    Array (y/n) [y]      : ')
    io_type = 'Array'
    if sys.stdin.readline().strip('\n') == 'n':
        io_type = 'ObjPtr'
    sys.stdout.write('    Required (y/n) [y]   : ')
    io_required = 'required'
    if sys.stdin.readline().strip('\n') == 'n':
        io_required = 'optional'
    sys.stdout.write('    Branch name [default]: ')
    io_branch = sys.stdin.readline().strip('\n')
    sys.stdout.write('    Variable name        : ')
    io_name = sys.stdin.readline().strip('\n')
    sys.stdout.write('    Description          : ')
    io_desc = sys.stdin.readline().strip('\n')
    init_header = init_header + '    Store%s<%s> m_%s; /**< %s */\n' \
        % (io_type, io_class, io_name, io_desc)
    header_includes.append('Store%s' % io_type)
    header_includes.append(io_class)
    if io_branch != '':
        ctor_src = ctor_src + ', m_%s("%s")' % (io_name, io_branch)
    io_required = io_required[0].upper() + io_required[1:]
    init_src = init_src + '  m_%s.is%s();\n' % (io_name, io_required)

sys.stdout.write('Please enter the output data types:\n')
while True:
    sys.stdout.write('  Output type            : ')
    io_class = sys.stdin.readline().strip('\n')
    if io_class == '':
        break
    sys.stdout.write('    Array (y/n) [y]      : ')
    io_type = 'Array'
    if sys.stdin.readline().strip('\n') == 'n':
        io_type = 'ObjPtr'
    sys.stdout.write('    Write out (y/n) [y]  : ')
    io_storeFlag = ''
    if sys.stdin.readline().strip('\n') == 'n':
        io_storeFlag = 'DataStore::c_DontWriteOut'
    sys.stdout.write('    Branch name [default]: ')
    io_branch = sys.stdin.readline().strip('\n')
    sys.stdout.write('    Variable name        : ')
    io_name = sys.stdin.readline().strip('\n')
    sys.stdout.write('    Description          : ')
    io_desc = sys.stdin.readline().strip('\n')
    init_header = init_header + '    Store%s<%s> m_%s; /**< %s */\n' \
        % (io_type, io_class, io_name, io_desc)
    header_includes.append('Store%s' % io_type)
    header_includes.append(io_class)
    if io_branch != '':
        ctor_src = ctor_src + ', m_%s("%s")' % (io_name, io_branch)
    init_src = init_src + '  m_%s.registerInDataStore(%s);\n' % (io_name,
             io_storeFlag)

# get module methods
methods_header = ''
methods_src = ''
sys.stdout.write("""Please select the required module methods:
""")
for method in [
    'initialize',
    'beginRun',
    'event',
    'endRun',
    'terminate',
    'destructor',
    ]:
    if method == 'initialize' and init_src != '':
        selected = True
        method_desc = 'Register input and output data'
    else:
        sys.stdout.write('  %-10s (y/n) [n]: ' % method)
        selected = sys.stdin.readline().strip('\n') == 'y'
        if selected:
            sys.stdout.write('    description       : ')
            method_desc = sys.stdin.readline().strip('\n')
    if selected:
        if method == 'destructor':
            methods_header = '''    /** %s */
    virtual ~%sModule();

''' \
                % (method_desc, module) + methods_header
            methods_src = '''%sModule::~%sModule()
{
}

''' % (module, module) \
                + methods_src
        else:
            methods_header = methods_header \
                + '''    /** %s */
    virtual void %s();

''' % (method_desc,
                    method)
            if method == 'initialize':
                methods_src = methods_src + '''void %sModule::%s()
{
%s}

''' \
                    % (module, method, init_src)
            else:
                methods_src = methods_src + '''void %sModule::%s()
{
}

''' \
                    % (module, method)

# determine include statements
header_includes = [f + '.h' for f in list(set(header_includes))]
src_includes = [f + '.h' for f in list(set(src_includes)
                - set(header_includes))]
includes_header = ''
includes_src = ''
release_dirs = [local_dir]
if os.environ.has_key('BELLE2_RELEASE_DIR'):
    release_dirs.append(os.environ['BELLE2_RELEASE_DIR'])

for release_dir in release_dirs:
    include_dir = os.path.join(release_dir, 'include')
    for (root, dirs, files) in os.walk(include_dir):
        if 'genfit' in root:
            continue
        for name in files:
            if name in header_includes:
                includes_header = includes_header + '#include <%s>\n' \
                    % os.path.relpath(os.path.join(root, name), include_dir)
                header_includes.remove(name)
            elif name in src_includes:
                includes_src = includes_src + '#include <%s>\n' \
                    % os.path.relpath(os.path.join(root, name), include_dir)
                src_includes.remove(name)

if len(header_includes + src_includes) > 0:
    sys.stderr.write('''
WARNING: The header files for the following classes were not found:
%s
'''
                     % ', '.join(header_includes + src_includes))

# write the header file
f = open(header, 'w')
f.write("""/**************************************************************************
 * BASF2 (Belle Analysis Framework 2)                                     *
 * Copyright(C) %d - Belle II Collaboration                             *
 *                                                                        *
 * Author: The Belle II Collaboration                                     *
 * Contributors: %-50s       *
 *                                                                        *
 * This software is provided "as is" without any warranty.                *
 **************************************************************************/

#ifndef %sMODULE_H
#define %sMODULE_H

#include <framework/core/Module.h>
%s

namespace Belle2 {
  /**
   * %s
   *
   * %s   *
   */
  class %sModule : public Module {

  public:

    /**
     * Constructor: Sets the description, the properties and the parameters of the module.
     */
    %sModule();

%s
  private:

%s%s  };
}

#endif /* %sMODULE_H */
"""
        % (  # year
             # copyright
             # include guards
             # include statements
             # doxygen comments
             # class name
             # constructor
             # methods
             # parameters and datastore objects
             # include guards comment
    datetime.datetime.now().year,
    author,
    module.upper(),
    module.upper(),
    includes_header,
    short_desc,
    '   * '.join(long_desc),
    module,
    module,
    methods_header,
    params_header,
    init_header,
    module.upper(),
    ))
f.close()

# write the source file
path = ''
f = open(src, 'w')
f.write("""/**************************************************************************
 * BASF2 (Belle Analysis Framework 2)                                     *
 * Copyright(C) 2013 - Belle II Collaboration                             *
 *                                                                        *
 * Author: The Belle II Collaboration                                     *
 * Contributors: %-50s       *
 *                                                                        *
 * This software is provided "as is" without any warranty.                *
 **************************************************************************/

#include <%s>
%s

using namespace Belle2;

//-----------------------------------------------------------------
//                 Register the Module
//-----------------------------------------------------------------
REG_MODULE(%s)

//-----------------------------------------------------------------
//                 Implementation
//-----------------------------------------------------------------

%sModule::%sModule() : Module()%s
{
  // Set module properties
  setDescription("%s");

  // Parameter definitions
%s
}

%s
"""
        % (  # copyright
             # include path
             # include statements
             # module registration
             # constructor
             # module description
             # module parameters
             # implementation of methods
    author,
    os.path.relpath(os.path.join(os.getcwd(), '%sModule.h' % module),
                    local_dir),
    includes_src,
    module,
    module,
    module,
    ctor_src,
    short_desc,
    params_src,
    methods_src,
    ))
f.close()

# add new files to svn
subprocess.call(['svn', 'add', header, src])
