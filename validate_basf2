#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
import os
import glob
import subprocess
import math
import datetime
import ROOT
ROOT.gROOT.SetBatch()
from optparse import OptionParser


results_dir = 'results'
output_dir = os.path.join(results_dir, 'current')
n_previous = 3
previous = []
directories = []
html_dir = 'html'


def parse_arguments():
    '''Parse the command line arguments'''
    
    global n_previous, previous, directories

    usage = '''usage: %prog [options] [packages]

Run basf2 validation tests of the given packages or sub-directories.
If no argument is given all validation tests are run.'''
    parser = OptionParser(usage=usage)
    parser.add_option('-n', type='int', dest='nPrevious', help='number of previous versions', default=3)
    parser.add_option('-p', action='append', dest='previous', help='name of previous version')
    (options, directories) = parser.parse_args()

    n_previous = options.nPrevious
    if options.previous != None:
        previous = options.previous

    # check whether a release is set up
    if not (os.environ.has_key('BELLE2_LOCAL_DIR')
            or os.environ.has_key('BELLE2_RELEASE_DIR')):
        sys.stderr.write('Error: no release is set up.\n')
        sys.exit(-1)


def process_dir(dir, output_subdir):
    """Execute validation tests in the given directory"""

    # go to the output directory
    out_dir = os.path.join(output_dir, output_subdir)
    if not os.path.exists(out_dir):
        os.makedirs(out_dir)
    cur_dir = os.getcwd()
    os.chdir(out_dir)

    # execute steering files
    for steering in glob.glob(os.path.join(dir, '*.py')):
        print 'Running: %s' % steering
        process = subprocess.Popen(['basf2', steering], stdout=subprocess.PIPE,
                                   stderr=subprocess.STDOUT)
        (out, err) = process.communicate()
        if process.returncode != 0:
            print ' -> FAILED'
            print out
            
    for macro in glob.glob(os.path.join(dir, '*.C')):
        print 'Running: %s' % macro
        process = subprocess.Popen(['root', '-b', '-q', macro], stdout=subprocess.PIPE,
                                   stderr=subprocess.STDOUT)
        (out, err) = process.communicate()
        if process.returncode != 0:
            print ' -> FAILED'
            print out

    # restore working directory
    os.chdir(cur_dir)


def process_top_dir(release_dir, processed_dirs):
    """Loop over folders in the top release directory"""

    global directories
    dirs = os.listdir(release_dir)
    if len(directories) > 0:
        dirs = directories

    exclude_dirs = [
        'build',
        'include',
        'lib',
        'bin',
        'modules',
        'data',
        'validation',
        ]
    for entry in dirs:
        if entry in processed_dirs:
            continue
        dir_entry = os.path.join(release_dir, entry, 'validation')
        if entry.find('.') > -1 or not os.path.isdir(dir_entry) or entry \
            in exclude_dirs:
            continue
        process_dir(dir_entry, entry)
        processed_dirs.append(entry)


def run_validations():
    '''execute the validation tests'''
    
    # make sure the output directory exists
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    # process local or central validation directory
    processed_dirs = []
    if len(directories) == 0 or 'validation' in directories:
        if os.environ.has_key('BELLE2_LOCAL_DIR'):
            validation_dir = os.path.join(os.environ['BELLE2_LOCAL_DIR'], 'validation')
            if os.path.isdir(validation_dir):
                process_dir(validation_dir, 'validation')
                processed_dirs.append(validation_dir)
        if os.environ.has_key('BELLE2_RELEASE_DIR') and len(processed_dirs) == 0:
            validation_dir = os.path.join(os.environ['BELLE2_RELEASE_DIR'], 'validation')
            if os.path.isdir(validation_dir):
                process_dir(validation_dir, 'validation')
                processed_dirs.append(validation_dir)
    
    # process local and central release directories
    if os.environ.has_key('BELLE2_LOCAL_DIR'):
        process_top_dir(os.environ['BELLE2_LOCAL_DIR'], processed_dirs)
    if os.environ.has_key('BELLE2_RELEASE_DIR'):
        process_top_dir(os.environ['BELLE2_RELEASE_DIR'], processed_dirs)


def collect_histos(dir, packages, index):
    """Collect histograms from the given directory"""

    if not os.path.isdir(dir):
        return

    global directories
    dirs = os.listdir(dir)
    if len(directories) > 0:
        dirs = directories

    for entry in dirs:
        dir_entry = os.path.join(dir, entry)
        if entry.find('.') > -1 or not os.path.isdir(dir_entry):
            continue
        if entry not in packages.keys():
            packages[entry] = {}
        for filename in glob.glob(os.path.join(dir_entry, '*.root')):
            basename = os.path.splitext(os.path.basename(filename))[0]
            if basename not in packages[entry].keys():
                packages[entry][basename] = {}
            root_file = ROOT.TFile(filename)
            for key in root_file.GetListOfKeys():
                name = key.GetName()
                obj = root_file.Get(name)
                if obj.InheritsFrom('TH1') or obj.InheritsFrom('TNtuple'):
                    if name not in packages[entry][basename].keys():
                        packages[entry][basename][name] = []
                    while len(packages[entry][basename][name]) <= index:
                        packages[entry][basename][name].append(None)
                    if obj.InheritsFrom('TH1'):
                        obj.SetDirectory(0)
                        packages[entry][basename][name][index] = obj
                    else:
                        obj.GetEntry(0)
                        packages[entry][basename][name][index] = {}
                        for leaf in obj.GetListOfLeaves():
                            packages[entry][basename][name][index][leaf.GetName()] = leaf.GetValue()


def collect_previous_histos(packages, versions):
    """Collect histograms of the previous validation tests"""

    dirs = os.listdir(results_dir)
    dirs.remove('current')
    dirs.sort(key=lambda x:os.stat(os.path.join(results_dir, x)).st_mtime, reverse=True)
    for entry in dirs:
        dir_entry = os.path.join(results_dir, entry)
        if not os.path.isdir(dir_entry):
            continue
        versions.append(entry)
        collect_histos(dir_entry, packages, len(versions)-1)


def create_indices(versions):
    '''Create an array of indices to the selected versions'''

    global n_previous, previous

    if n_previous >= len(versions):
        n_previous = len(versions)-1
    for version in previous:
        if version in versions[:n_previous+1]:
            previous.remove(version)
    indices = range(n_previous+1)
    for version in previous:
        indices.append(versions.index(version))

    return indices

    
def create_html(packages, versions, indices):
    '''Create a html file and write header information'''
    
    # make sure the html directory exists
    if not os.path.exists(html_dir):
        os.makedirs(html_dir)

    # create frameset
    frame = open(os.path.join(html_dir, 'validation.html'), 'w')
    frame.write('''<html>
<head>
<title>Validation</title>
</head>
<frameset cols="250,*">
  <frame src="validation_menu.html" name="menu">
  <frame src="validation_plots.html" name="plots">
</frameset>
</html>
''' )

    # create html file with title, legend, and navigation
    menu = open(os.path.join(html_dir, 'validation_menu.html'), 'w')
    menu.write('''<html>
<body>
<p><b>%s</b></p>
''' % datetime.datetime.now().ctime())
    menu.write('<p>\n<b>Legend:</b>\n<ul>\n')
    for index in range(len(indices)):
        menu.write('<li style="color:%s">%s</li>\n' % (ROOT.gROOT.GetColor(index+1).AsHexString(), versions[indices[index]]))
    menu.write('</ul>\n</p><br>\n\n')
    for package in packages.keys():
        menu.write('<p><h3><a target="plots" href="validation_plots.html#%s">%s</a></h3>\n<ul>\n' % (package, package))
        for basename in packages[package].keys():
            menu.write('<li><a target="plots" href="validation_plots.html#%s_%s">%s</a></li>\n' % (package, basename, basename))
        menu.write('</ul></p>\n\n')
    menu.write('</body>\n</html>\n')

    # create main html file for plots
    html = open(os.path.join(html_dir, 'validation_plots.html'), 'w')    
    html.write('<html>\n<body>\n')
    return html


def make_plots(html, packages, versions, indices):
    '''Create the plots and add them to the html page'''
    
    # produce plots
    for package in packages.keys():
        html.write('<br><a name="%s"><h2>%s</h2></a>\n' % (package, package))
        for basename in packages[package].keys():
            html.write('<a name="%s_%s"><h3>%s</h3></a>\n' % (package, basename, basename))
            for name in packages[package][basename].keys():
                plots = packages[package][basename][name]

                # prepare histograms
                split = False
                ntuple = False
                variables = []
                for index in range(len(indices)):
                    while len(plots) <= indices[index]:
                        plots.append(None)
                    histo = plots[indices[index]]
                    if histo:
                        if isinstance(histo, ROOT.TH1):
                            histo.SetLineColor(index+1)
                            if index == 0:
                                histo.SetLineWidth(2*histo.GetLineWidth())
                            histo.SetStats(0)
                            if histo.InheritsFrom('TH2') or histo.InheritsFrom('TH3'):
                                split = True
                        else:
                            ntuple = True
                            variables = histo.keys()

                if not ntuple:
                    # create canvas
                    can = ROOT.TCanvas()
                    if split:
                        nSplit = int(math.sqrt(len(indices)-1)) + 1
                        can.Divide(nSplit, nSplit)

                    # draw histograms
                    for index in range(len(indices)):
                        histo = plots[indices[index]]
                        if histo:
                            option = histo.GetOption()
                            if split:
                                can.cd(index+1)
                                histo.DrawCopy(option)
                            else:
                                histo.DrawCopy(option)
                                option = 'same ' + option

                    # save image
                    filename = '%s_%s_%s.png' % (package, basename, name)
                    can.Print(os.path.join(html_dir, '%s.png' % filename))
                    can.Print(os.path.join(html_dir, '%s.eps' % filename))
                    html.write('<a href="%s.eps"><img src="%s.png"></a><br>\n' % (filename, filename))

                else:
                    html.write('<table border=1>\n<tr><th>%s</th>' % name)
                    for var in variables:
                        html.write('<th>%s</th>' % var)
                    for index in range(len(indices)):
                        html.write('</tr>\n<tr><td align=right style="color:%s">%s</td>' % (ROOT.gROOT.GetColor(index+1).AsHexString(), versions[indices[index]]))
                        for var in variables:
                            values = plots[indices[index]]
                            if values:
                                html.write('<td align=right>%g</td>' % values[var])
                            else:
                                html.write('<td>n/a</td>')
                        html.write('<br>\n')
                    html.write('</tr></table>\n')


def close_html(html):
    '''Close the html file'''
    
    html.write('''</body>
    </html>
    ''')
    html.close()


# parse command line arguments and run validation tests
parse_arguments()
run_validations()

# collect output histograms
packages = {}  # dictionary of packages -> dictionary of root files -> dictionary of histograms -> array[version]
versions = ['current']
collect_histos(output_dir, packages, 0)
collect_previous_histos(packages, versions)
indices = create_indices(versions)

# create plots and html file
if len(packages.keys()) > 0:
    html = create_html(packages, versions, indices)
    make_plots(html, packages, versions, indices)
    close_html(html)


